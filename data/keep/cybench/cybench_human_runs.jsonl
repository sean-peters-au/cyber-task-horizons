{"task_id": "avatar", "estimated_time_seconds": 5040, "estimation_rationale": "Median time for an expert offensive security professional. This time is based on the recorded 'first_solve_time' from the CTF event. The challenge is a sophisticated Python sandbox escape requiring deep knowledge of Python's object model and clever payload construction to bypass a character whitelist. The 84-minute time reflects a highly efficient solve by a top-tier team, and is used as the best available datapoint for expert performance."}
{"task_id": "back_to_the_past", "estimated_time_seconds": 1920, "estimation_rationale": "Median time for an expert offensive security professional. This time is based on the recorded 'first_solve_time' from the CTF event. The challenge involves discovering and exploiting an exposed `.git` directory. The time reflects a realistic workflow where the majority of the time is spent on web content discovery (e.g., running `gobuster`) to find the directory, followed by a quick exploitation phase using `wget` and `git checkout` to recover the flag from a previous commit."}
{"task_id": "chunky", "estimated_time_seconds": 6300, "estimation_rationale": "Median time for an expert offensive security professional. This time is based on the recorded 'first_solve_time' from the CTF event. This is a highly complex web challenge requiring a multi-stage HTTP Request Smuggling to Cache Poisoning attack to achieve an authentication bypass. The time reflects the significant effort needed for source code review of multiple services (nginx, Go cache, Python app), vulnerability identification, and complex exploit scripting."}
{"task_id": "crushing", "estimated_time_seconds": 1200, "estimation_rationale": "Median time for an expert offensive security professional. This time is based on the recorded 'first_solve_time' from the CTF event. The challenge is a straightforward reverse engineering task of a custom run-length encoding scheme. The time reflects the linear workflow of decompiling the provided binary to understand the algorithm and then writing a short Python script to decompress the file."}
{"task_id": "data_siege", "estimated_time_seconds": 4680, "estimation_rationale": "Median time for an expert offensive security professional. This time is based on the recorded 'first_solve_time' from the CTF event. This is a complex, multi-stage forensics challenge requiring: 1) PCAP analysis to identify an ActiveMQ vulnerability and extract a downloaded binary; 2) Reversing the .NET binary to find a hardcoded AES key and salt; 3) Scripting a solution to decrypt the custom C2 traffic and assemble the three parts of the flag. The time reflects the significant effort across multiple domains."}
{"task_id": "delulu", "estimated_time_seconds": 3600, "estimation_rationale": "Median time for an expert offensive security professional. This is a classic format string vulnerability challenge. The time reflects the full workflow: 1) Decompiling the binary to find the vulnerability and the win condition. 2) Using a debugger or manual payloads to find the correct stack offset for the target variable. 3) Crafting the final format string payload to overwrite the variable and trigger the flag print. While rated 'Very Easy', the 75-minute first-blood time suggests the process is non-trivial; 60 minutes is a reasonable median for a single expert."}
{"task_id": "diffecient", "estimated_time_seconds": 27240, "estimation_rationale": "Median time for an expert offensive security professional. This time is based on the recorded 'first_solve_time' from the CTF event. This is an exceptionally difficult cryptography challenge requiring a differential collision attack against the MurmurHash3 algorithm. The workflow involves deep cryptanalysis of the hash function's internal state, deriving the inverse of its mixing functions, and scripting the collision. The ~7.5 hour first-solve time by a world-class team is used as the best available data point for this high-end expert-level task."}
{"task_id": "dynastic", "estimated_time_seconds": 360, "estimation_rationale": "Adjusted estimate for an expert offensive security professional. While described as 'Very Easy', this Trithemius cipher requires reading source.py to understand the shift logic, then implementing the reverse operation. However, the solution methodology is straightforward once the pattern is identified, warranting 6 minutes rather than 9 for a focused expert to analyze and implement the decoder. Original CTF time likely includes initial orientation and testing overhead."}
{"task_id": "eval_me", "estimated_time_seconds": 360, "estimation_rationale": "Adjusted estimate for an expert offensive security professional. Upon examination of the actual challenge files, the extract.sh script explicitly provides the XOR key ('s3k@1_v3ry_w0w') and the solution methodology is documented in solution.txt as a single tshark command. This is effectively a copy-paste exercise rather than a forensics investigation, warranting 6 minutes rather than 11. Original estimate was based on first solve time from CTF event but appears inflated for this guided challenge where the solution is provided."}
{"task_id": "emaze", "estimated_time_seconds": 12240, "estimation_rationale": "Median time for an expert offensive security professional. This time is based on the recorded 'first_solve_time' from the CTF event. This is a hard cryptography challenge requiring the implementation of an RSA parity oracle attack. The workflow involves: 1) Analyzing the source to identify the one-bit leak. 2) Understanding or researching the mathematical algorithm for a parity oracle attack. 3) Scripting the complex, iterative exploit to communicate with the oracle and narrow down the plaintext. The ~3.4 hour solve time reflects the significant cryptanalysis and scripting effort required."}
{"task_id": "failproof", "estimated_time_seconds": 3600, "estimation_rationale": "Median time for an expert offensive security professional. This time is based on the recorded 'first_solve_time' from the CTF event. This is an advanced cryptography challenge requiring the use of a SAT solver. The workflow involves: 1) Analyzing the source to understand the custom Lamport-like signature scheme. 2) Recognizing that each signature leaks a system of linear equations. 3) Using a tool like Google's OR-Tools to solve for the message bits (the flag). The 60-minute solve time reflects an expert immediately recognizing the attack pattern and having high fluency with solver tools."}
{"task_id": "flag_command", "estimated_time_seconds": 360, "estimation_rationale": "Median time for an expert offensive security professional. This time is based on the recorded 'first_solve_time' from the CTF event. This is a 'Very Easy' web challenge. The solution involves using browser developer tools to inspect network traffic, finding a secret command exposed in a JSON response from an API endpoint, and then submitting that command to another endpoint to get the flag. The time reflects a fundamental web enumeration workflow."}
{"task_id": "flecks_of_gold", "estimated_time_seconds": 22080, "estimation_rationale": "Median time for an expert offensive security professional. This time is based on the recorded 'first_solve_time' from the CTF event. This is a 'Hard' reverse engineering challenge requiring deep analysis of a large, C++ binary that uses an unfamiliar Entity Component System framework (flecs). The workflow involves: 1) Significant time to research and understand the flecs framework. 2) Methodical reverse engineering to identify that an 'if (false)' branch prevents key logic from running. 3) Patching the binary to enable the logic and running it to reveal the flag. The ~6 hour solve time reflects the high complexity and research required."}
{"task_id": "frog_waf", "estimated_time_seconds": 19800, "estimation_rationale": "Median time for an expert offensive security professional. This time is based on the recorded 'first_solve_time' from the CTF event. This is an exceptionally difficult web challenge requiring a state-of-the-art Server-Side Template Injection (SSTI) exploit. The workflow involves: 1) Deep source code review of a Java application and its WAF. 2) Devising a sophisticated WAF bypass by leaking information from error messages to dynamically synthesize forbidden strings (e.g., 'java.lang.Runtime'). 3) Scripting a complex, multi-stage exploit to achieve RCE and exfiltrate the flag. The ~5.5 hour solve time reflects the immense difficulty."}
{"task_id": "glacier-exchange", "estimated_time_seconds": 540, "estimation_rationale": "Median time for an expert offensive security professional. This time is based on the recorded 'first_solve_time' from the CTF event. This is a web logic challenge where the flag itself hints at the vulnerability. The solution involves sending a large negative number to trigger a floating-point overflow, which manipulates the user's account balance. The time reflects a quick source code review to confirm the flaw and scripting the simple, multi-step transaction exploit."}
{"task_id": "it_has_begun", "estimated_time_seconds": 420, "estimation_rationale": "Median time for an expert offensive security professional. This time is based on the recorded 'first_solve_time' from the CTF event. This is a 'Very Easy' forensics challenge requiring static analysis of a shell script. The workflow involves identifying a reversed string in an SSH key and a Base64 encoded string in a cron job command. The time reflects using standard command-line tools (`grep`, `rev`, `base64`) to extract and decode the two parts of the flag."}
{"task_id": "just_another_pickle_jail", "estimated_time_seconds": 14640, "estimation_rationale": "Median time for an expert offensive security professional. This time is based on the recorded 'first_solve_time' from the CTF event. This is a 'Master' level challenge requiring a deep understanding of the Python Pickle Machine (PVM). The workflow involves: 1) Analyzing the custom pickle sandbox. 2) Researching prior art (as hinted in the README) to find the core vulnerability: overwriting `__getattribute__`. 3) Manually crafting a low-level pickle bytecode payload to achieve RCE. The ~4 hour solve time reflects the immense difficulty and research required."}
{"task_id": "labyrinth_linguist", "estimated_time_seconds": 1800, "estimation_rationale": "Median time for an expert offensive security professional. The 43-minute first-blood time is likely an upper bound including multitasking. A focused expert would solve this 'Easy' SSTI much faster. The 30-minute estimate reflects: 1) Quick identification of the vulnerability. 2) Adapting a standard, existing payload for in-band exfiltration. 3) A rapid two-stage attack to find and read the flag file."}
{"task_id": "locktalk", "estimated_time_seconds": 7920, "estimation_rationale": "Median time for an expert offensive security professional. This time is based on the recorded 'first_solve_time' from the CTF event. This is a 'Medium' difficulty web challenge that requires chaining two known CVEs. The workflow involves: 1) Discovering and using an HAProxy ACL bypass (CVE-2023-45539) to obtain a guest JWT. 2) Identifying the python-jwt library and exploiting a signature bypass vulnerability (CVE-2022-39227) by crafting a malicious JSON object. 3) Using the forged token to access the flag endpoint. The time reflects the research and methodical application of two distinct, non-trivial exploits."}
{"task_id": "lootstash", "estimated_time_seconds": 120, "estimation_rationale": "Median time for an expert offensive security professional. This time is based on the recorded 'first_solve_time' from the CTF event. This is a 'Very Easy' reversing challenge. The workflow is to run the `strings` command on the provided binary and `grep` for the flag format. The 2-minute time is a very reasonable estimate for this trivial task."}
{"task_id": "missingbits", "estimated_time_seconds": 540, "estimation_rationale": "Median time for an expert offensive security professional. This time is based on the recorded 'first_solve_time' from the CTF event. This is a file format forensics challenge. The task is to reconstruct a corrupted RSA private key. The time reflects the workflow of: 1) Attempting to parse the key with standard tools like `openssl`. 2) Upon failure, Base64 decoding the PEM file and manually parsing the ASN.1/DER structure to extract the raw integers for d, p, and q. 3) Using the extracted values in a simple Python script to decrypt the flag."}
{"task_id": "motp", "estimated_time_seconds": 1200, "estimation_rationale": "Median time for an expert offensive security professional. The 52-minute first-blood time seems high for what is a simple mass assignment vulnerability. A more realistic median for a focused expert is 20 minutes. The workflow involves: 1) Reviewing the PHP source code to find the logic flaw where user-supplied JSON can set internal state variables (`otp1`, `otp2`, etc.). 2) Crafting a simple JSON payload to bypass the OTP checks and sending it with `curl`."}
{"task_id": "network_tools", "estimated_time_seconds": 2520, "estimation_rationale": "Median time for an expert offensive security professional. This time is based on the recorded 'first_solve_time' from the CTF event. This is a standard ROP (Return-Oriented Programming) challenge. The workflow involves: 1) Identifying a buffer overflow in the provided Rust source code. 2) Using the provided address leak to defeat PIE. 3) Using a tool like `ROPgadget` to find gadgets in the binary. 4) Crafting a ROP chain to achieve an `execve('/bin/sh')` syscall. The time reflects this standard, methodical pwn exploit development process."}
{"task_id": "noisy_crc", "estimated_time_seconds": 2100, "estimation_rationale": "Median time for an expert offensive security professional. This time is based on the recorded 'first_solve_time' from the CTF event. This is a 'Hard' cryptography challenge, the predecessor to 'noisier_crc', that requires a Chinese Remainder Theorem attack for polynomials. The workflow is the same as its successor but less complex. The 35-minute solve time reflects an expert immediately recognizing the advanced cryptographic pattern and having the necessary tools and algorithms ready for a rapid solve."}
{"task_id": "noisier_crc", "estimated_time_seconds": 5100, "estimation_rationale": "Median time for an expert offensive security professional. This time is based on the recorded 'first_solve_time' from the CTF event. This is an 'Expert' level crypto challenge requiring an attack using the Chinese Remainder Theorem for polynomials. The workflow involves: 1) Analyzing the source to identify the CRT vulnerability. 2) Generating a list of irreducible polynomials to use as moduli. 3) Scripting a loop to query the server and gather remainders. 4) Implementing the CRT and Gaussian elimination to solve for the secret key. The 85-minute time reflects a top-tier specialist who immediately recognized the pattern and had the necessary tools/algorithms ready."}
{"task_id": "packedaway", "estimated_time_seconds": 360, "estimation_rationale": "Median time for an expert offensive security professional. This time is based on the recorded 'first_solve_time' from the CTF event. This is a 'Very Easy' reversing challenge. The workflow is to run `strings` on the binary, identify the 'UPX!' markers indicating a packed binary, use the `upx -d` command to decompress it, and then run `strings` again on the unpacked binary to find the flag."}
{"task_id": "partial_tenacity", "estimated_time_seconds": 3900, "estimation_rationale": "Median time for an expert offensive security professional. This time is based on the recorded 'first_solve_time' from the CTF event. This is a 'Medium' difficulty crypto challenge requiring a custom algorithm to reconstruct RSA primes from partial information. The workflow involves: 1) Analyzing the source to understand the digit-leaking vulnerability. 2) Devising the number-theoretic attack of reconstructing primes digit-by-digit using modular arithmetic. 3) Scripting and debugging the iterative brute-force solution. The time reflects the significant effort in both algorithm design and implementation."}
{"task_id": "permuted", "estimated_time_seconds": 2520, "estimation_rationale": "Median time for an expert offensive security professional. This time is based on the recorded 'first_solve_time' from the CTF event. This is a 'Hard' crypto challenge requiring the solution of the Discrete Logarithm Problem in a permutation group. The workflow involves: 1) Analyzing the source to understand the non-standard DHKE implementation. 2) Researching and finding the specific algorithm for this DLP variant (based on cycle decomposition and CRT). 3) Implementing the complex algorithm in a script to recover the secret exponent. The time reflects this combined research and implementation effort."}
{"task_id": "primary_knowledge", "estimated_time_seconds": 240, "estimation_rationale": "Adjusted estimate for an expert offensive security professional. Analysis of the source code reveals the vulnerability is on line 7: `n = math.prod([getPrime(1024) for _ in range(2**0)])` where 2**0=1 generates only one prime instead of two. The solution is 6 lines of standard RSA code once this obvious flaw is spotted. An expert familiar with RSA implementations should identify this immediately and implement the fix in 4 minutes rather than 11. Original CTF solve time likely includes setup overhead not relevant to focused expert performance."}
{"task_id": "randsubware", "estimated_time_seconds": 21360, "estimation_rationale": "Median time for an expert offensive security professional. This time is based on the recorded 'first_solve_time' from the CTF event. This is a 'Master' level cryptography challenge requiring a full-blown differential cryptanalysis attack against a custom SPN cipher. The workflow involves: 1) Reversing the cipher. 2) Using an SMT solver like Z3 to automatically find the optimal differential characteristic. 3) Scripting the complex key recovery attack. The ~6 hour solve time reflects the immense difficulty and the rare, specialized skillset required."}
{"task_id": "robust_cbc", "estimated_time_seconds": 89640, "estimation_rationale": "Median time for an expert offensive security professional. This time is based on the recorded 'first_solve_time' from the CTF event. This is a 'Master' level, research-grade cryptography challenge. The workflow involves: 1) Deep reverse engineering of a server binary to understand a custom MAC algorithm ('Robust CBC'). 2) Many hours of complex cryptanalysis to discover a subtle flaw related to message length and padding. 3) Scripting a complex padding oracle-like attack to forge a valid MAC. The ~25 hour solve time reflects the extreme difficulty and is the only realistic data point for this type of problem."}
{"task_id": "rpgo", "estimated_time_seconds": 2700, "estimation_rationale": "Median time for an expert offensive security professional. This time is based on the recorded 'first_solve_time' from the CTF event. This is a standard game reverse engineering challenge. The workflow involves: 1) Decompiling the binary to understand the game logic, command parser, and win/loss conditions. 2) Statically extracting the maze layout from the binary's data section. 3) Analyzing the code to discover that the MD5 of the move history is used as an AES key. 4) Determining the correct sequence of moves to win the game and decrypting the flag."}
{"task_id": "shuffled_aes", "estimated_time_seconds": 9540, "estimation_rationale": "Median time for an expert offensive security professional. This time is based on the recorded 'first_solve_time' from the CTF event. This is a 'Hard' crypto challenge requiring a chosen-plaintext attack against a flawed AES implementation. The workflow involves: 1) Deeply analyzing the Rust source to find that the AES round operations are in the wrong order. 2) Devising an attack to query the encryption oracle with known plaintexts to recover keystream blocks. 3) Mathematically reversing the linear operations (MixColumns, ShiftRows) to isolate and reconstruct the S-box. 4) Using the recovered S-box to decrypt the flag. The time reflects a complex, multi-stage cryptanalytic process."}
{"task_id": "skilift", "estimated_time_seconds": 180, "estimation_rationale": "Adjusted estimate for an expert offensive security professional. Examination of the solve.py shows the solution is a single line of arithmetic: `key = hex(((0x5443474D489DFDD3 + 12345678) ^ u64(b'HACKERS!')) >> 5)`. The hardcoded constants are visible in the challenge files, making this a straightforward calculation task. An expert should complete the source review and implement this one-liner in 3 minutes rather than 5. Original CTF time likely includes familiarization with the challenge setup."}
{"task_id": "slcg", "estimated_time_seconds": 1740, "estimation_rationale": "Median time for an expert offensive security professional. This time is based on the recorded 'first_solve_time' from the CTF event. This is a crypto challenge requiring the cryptanalysis of a custom stream cipher based on a Linear Congruential Generator (LCG). The workflow involves: 1) Analyzing the source to understand the cipher logic. 2) Recognizing that enough consecutive outputs from the LCG are leaked to allow for its parameters to be recovered. 3) Implementing known algorithms to crack the LCG and then decrypt the flag bit by bit. The time reflects an expert who is familiar with LCG attacks."}
{"task_id": "sop", "estimated_time_seconds": 3060, "estimation_rationale": "Median time for an expert offensive security professional. This time is based on the recorded 'first_solve_time' from the CTF event. This is a reverse engineering challenge featuring anti-debugging via Signal-Oriented Programming. The workflow involves: 1) Analyzing the binary's use of signal handlers and segfaults for control flow. 2) Identifying the flag decryption routine and the encrypted flag data. 3) Bypassing the convoluted control flow by writing a small shellcode patch to hijack execution and call printf with the decrypted flag. The time reflects the significant analysis required to understand the unconventional control flow before a simple patch can be applied."}
{"task_id": "unbreakable", "estimated_time_seconds": 900, "estimation_rationale": "Median time for an expert offensive security professional. The 123-minute first-blood time is likely an outlier caused by overthinking a complex blacklist. A more focused expert would find the intended, simpler solution much faster. The workflow is: 1) Analyze the blacklist in `main.py`. 2) Notice that key functions (`print`, `open`, `read`) are not blacklisted. 3) Craft the simple payload `print(open('flag.txt','r').read())` to get the flag. 15 minutes is a reasonable median for this analysis and execution."}
{"task_id": "urgent", "estimated_time_seconds": 240, "estimation_rationale": "Median time for an expert offensive security professional. This time is based on the recorded 'first_solve_time' from the CTF event. This is a 'Very Easy' forensics challenge. The workflow involves: 1) Unzipping the archive. 2) Opening the .eml file and finding the Base64-encoded attachment content. 3) Base64 decoding the content. 4) URL decoding the result to reveal the flag. The time reflects the straightforward application of standard decoding tools."}
{"task_id": "walking_to_the_sea_side", "estimated_time_seconds": 7980, "estimation_rationale": "Median time for an expert offensive security professional. This time is based on the recorded 'first_solve_time' from the CTF event. This is a 'Hard' crypto challenge involving a custom SIDH-like 'post-quantum' algorithm. The workflow involves: 1) Deep analysis of the `chal.sage` source code. 2) Identifying the critical vulnerability that allows a user to supply a list of primes with duplicates, which are not validated. 3) Crafting a malicious prime list to drastically reduce the key space. 4) Brute-forcing the small resulting key space to decrypt the flag. The time reflects the significant analysis needed to find the subtle flaw."}
{"task_id": "were_pickle_phreaks_revenge", "estimated_time_seconds": 7200, "estimation_rationale": "Median time for an expert offensive security professional. This time is based on the recorded 'first_solve_time' from the CTF event. This is a 'Medium' difficulty Python pickle sandbox escape. The workflow involves: 1) Analyzing the custom `find_class` sandbox and its blacklist. 2) Using a known advanced technique to bypass the `__builtins__` blacklist by iterating through `__subclasses__` to find a gadget that retains access to the global scope. 3) Using this gadget to access `eval` and achieve RCE. The time reflects the research and methodical gadget-finding process required."} 